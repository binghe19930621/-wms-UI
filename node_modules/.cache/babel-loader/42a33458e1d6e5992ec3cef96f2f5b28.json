{"remainingRequest":"E:\\项目\\SKWMS\\wms-ui\\node_modules\\babel-loader\\lib\\index.js!E:\\项目\\SKWMS\\wms-ui\\node_modules\\eslint-loader\\index.js??ref--13-0!E:\\项目\\SKWMS\\wms-ui\\src\\util\\CollectionUtil.js","dependencies":[{"path":"E:\\项目\\SKWMS\\wms-ui\\src\\util\\CollectionUtil.js","mtime":1585370816108},{"path":"E:\\项目\\SKWMS\\wms-ui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\项目\\SKWMS\\wms-ui\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"E:\\项目\\SKWMS\\wms-ui\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _Object$assign from \"E:\\\\\\u9879\\u76EE\\\\SKWMS\\\\wms-ui\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/object/assign\";\nimport _Set from \"E:\\\\\\u9879\\u76EE\\\\SKWMS\\\\wms-ui\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/set\";\nimport _toConsumableArray from \"E:\\\\\\u9879\\u76EE\\\\SKWMS\\\\wms-ui\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _getIterator from \"E:\\\\\\u9879\\u76EE\\\\SKWMS\\\\wms-ui\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/get-iterator\";\nimport \"core-js/modules/es6.array.find\";\nexport default {\n  /**\r\n   * 深度查找对象是否存在\r\n   * @param collection    集合\r\n   * @param find  回调函数\r\n   * @param childKey  子集合字段名称\r\n   * @returns {null}\r\n   */\n  findDeep: function findDeep(collection, find) {\n    var childKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';\n    var res = null;\n    res = collection.find(find) || null;\n    if (res) return res;\n\n    for (var i = 0; i < collection.length; i++) {\n      var D = collection[i];\n\n      if (D[childKey] && D[childKey].length > 0) {\n        res = this.findDeep(D[childKey], find, childKey);\n        if (res) break;\n      }\n    }\n\n    return res;\n  },\n\n  /**\r\n   * 查找集合是否存在\r\n   * 返回集合 index 值\r\n   * @param collection\r\n   * @param find\r\n   * @returns {number}\r\n   */\n  findIndex: function findIndex(collection, find) {\n    var res = -1;\n\n    for (var i = 0; i < collection.length; i++) {\n      var C = collection[i];\n      var r = true;\n\n      for (var j in find) {\n        var D = find[j];\n        if (typeof C[j] !== \"undefined\" && C[j] === D) continue;\n        r = false;\n        break;\n      }\n\n      if (r) res = i;\n    }\n\n    return res;\n  },\n\n  /**\r\n   * 一般数组转换为树状结构\r\n   * @param list\r\n   * @param pid\r\n   * @param idKey\r\n   * @param pidKey\r\n   * @param childKey\r\n   * @returns {Array}\r\n   */\n  listToTree: function listToTree(list) {\n    var pid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var idKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n    var pidKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'pid';\n    var childKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'children';\n    var res = [];\n\n    for (var i in list) {\n      var D = list[i];\n\n      if (D[pidKey] === pid) {\n        var r = this.listToTree(list, D[idKey], idKey, pidKey, childKey);\n        if (r.length) D[childKey] = r;\n        res.push(D);\n      }\n    }\n\n    return res;\n  },\n\n  /**\r\n   * 树状结构筛选\r\n   * 需要保证还有子节点的父节点不被过滤\r\n   * @param tree\r\n   * @param filter\r\n   * @param idKey\r\n   * @param childKey\r\n   * @param deep\r\n   * @param nowDeep\r\n   * @returns {Array}\r\n   */\n  filterTree: function filterTree(tree, filter) {\n    var childKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';\n    var deep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var nowDeep = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var res = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(tree), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var leaf = _step.value;\n        var show = (deep === null || deep === nowDeep + 1) && filter(leaf);\n\n        if (leaf.children && leaf.children.length) {\n          leaf.children = this.filterTree(leaf.children, filter, childKey, deep, nowDeep + 1);\n        }\n\n        if (show || leaf.children && leaf.children.length) {\n          res.push(leaf);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\r\n   * 将树状结构扁平化\r\n   * @param tree\r\n   * @param childKey\r\n   * @returns {Array}\r\n   */\n  platTrees: function platTrees(tree) {\n    var childKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'children';\n    var res = [];\n\n    for (var i in tree) {\n      var D = tree[i];\n      res.push(res);\n\n      if (D[childKey]) {\n        res.concat(this.platTrees(D[(childKey, childKey)]));\n      }\n    }\n\n    return res;\n  },\n\n  /**\r\n   * 查询路径\r\n   * @param tree\r\n   * @param find\r\n   * @param key\r\n   * @param childKey\r\n   * @param deep\r\n   * @param nowDeep\r\n   * @returns {Array}\r\n   */\n  getTreeRoute: function getTreeRoute(tree, find) {\n    var _this = this;\n\n    var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n    var childKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var deep = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var nowDeep = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var ret = [];\n    childKey = childKey || 'children';\n    tree.forEach(function (x) {\n      var is = (deep === null || deep === nowDeep + 1) && find(x);\n\n      if (is) {\n        ret.push(x[key]);\n      } else if (x[childKey] && x[childKey].length) {\n        var r = _this.getTreeRoute(x[childKey], find, key, childKey, deep, nowDeep + 1);\n\n        if (r.length) {\n          ret = [x[key]].concat(_toConsumableArray(r));\n        }\n      }\n    });\n    return ret;\n  },\n\n  /**\r\n   * 并集\r\n   * @param coll1\r\n   * @param coll2\r\n   * @returns {...*[]}\r\n   */\n  merge: function merge(coll1, coll2) {\n    return _toConsumableArray(new _Set([].concat(_toConsumableArray(coll1), _toConsumableArray(coll2))));\n  },\n\n  /**\r\n   * 差集\r\n   * @param coll1\r\n   * @param coll2\r\n   * @param diff\r\n   * @returns {Array}\r\n   */\n  diff: function diff(coll1, coll2) {\n    var _diff = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    var ret = [];\n    coll1.forEach(function (x1) {\n      var t = coll2.find(function (x2) {\n        return x2 === x1;\n      });\n\n      if (_diff && !t) {\n        ret.push(x1);\n      }\n\n      if (!_diff && t) {\n        ret.push(x1);\n      }\n    });\n    coll2.forEach(function (x1) {\n      var t = coll1.find(function (x2) {\n        return x2 === x1;\n      });\n\n      if (_diff && !t) {\n        ret.push(x1);\n      }\n\n      if (!_diff && t) {\n        ret.push(x1);\n      }\n    });\n    return ret;\n  },\n\n  /**\r\n   * 交集\r\n   * @param coll1\r\n   * @param coll2\r\n   * @returns {*|Array}\r\n   */\n  intersect: function intersect(coll1, coll2) {\n    return this.diff(coll1, coll2, false);\n  },\n\n  /**\r\n   * 交集和并集\r\n   * 如果存在交集 这取差集\r\n   * 如果不存在交集 则取并集\r\n   * @param coll1\r\n   * @param coll2\r\n   * @returns {*|Array|*}\r\n   */\n  mergeDiff: function mergeDiff(coll1, coll2) {\n    var m = this.merge(coll1, coll2);\n\n    if (m.length > coll1.length && m.length > coll2.length) {\n      return m;\n    }\n\n    var t = coll1.length > coll2.length ? coll2 : coll1;\n    return this.diff(m, t);\n  },\n\n  /**\r\n   * 将两个有所属关系的列表合并为树状结构\r\n   * @param parentList\r\n   * @param childList\r\n   * @param childKey\r\n   * @param idKey\r\n   * @param pid\r\n   * @returns {Array|*[]}\r\n   */\n  listToTreeByTwoList: function listToTreeByTwoList() {\n    var parentList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var childList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var pid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';\n    var childKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'children';\n    var idKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'id';\n    if (!childList.length) return parentList;\n    return parentList.map(function (p) {\n      var c = {};\n      c[childKey] = childList.filter(function (ch) {\n        return ch[pid] === p[idKey];\n      });\n      return _Object$assign(p, c);\n    });\n  }\n};",{"version":3,"sources":["E:\\项目\\SKWMS\\wms-ui\\src\\util\\CollectionUtil.js"],"names":["findDeep","collection","find","childKey","res","i","length","D","findIndex","C","r","j","listToTree","list","pid","idKey","pidKey","push","filterTree","tree","filter","deep","nowDeep","leaf","show","children","platTrees","concat","getTreeRoute","key","ret","forEach","x","is","merge","coll1","coll2","diff","x1","t","x2","intersect","mergeDiff","m","listToTreeByTwoList","parentList","childList","map","p","c","ch"],"mappings":"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","sourcesContent":["export default {\r\n\r\n    /**\r\n     * 深度查找对象是否存在\r\n     * @param collection    集合\r\n     * @param find  回调函数\r\n     * @param childKey  子集合字段名称\r\n     * @returns {null}\r\n     */\r\n    findDeep(collection, find, childKey = 'children') {\r\n        let res = null;\r\n        res = collection.find(find) || null;\r\n        if (res) return res;\r\n        for (let i = 0; i < collection.length; i++) {\r\n            let D = collection[i];\r\n            if (D[childKey] && D[childKey].length > 0) {\r\n                res = this.findDeep(D[childKey], find, childKey);\r\n                if (res) break;\r\n            }\r\n        }\r\n        return res;\r\n    },\r\n\r\n    /**\r\n     * 查找集合是否存在\r\n     * 返回集合 index 值\r\n     * @param collection\r\n     * @param find\r\n     * @returns {number}\r\n     */\r\n    findIndex(collection, find) {\r\n        let res = -1;\r\n        for (let i = 0; i < collection.length; i++) {\r\n            let C = collection[i];\r\n            let r = true;\r\n            for (let j in find) {\r\n                let D = find[j];\r\n                if (typeof C[j] !== \"undefined\" && C[j] === D) continue;\r\n                r = false;\r\n                break;\r\n            }\r\n            if (r) res = i;\r\n        }\r\n        return res;\r\n    },\r\n\r\n    /**\r\n     * 一般数组转换为树状结构\r\n     * @param list\r\n     * @param pid\r\n     * @param idKey\r\n     * @param pidKey\r\n     * @param childKey\r\n     * @returns {Array}\r\n     */\r\n    listToTree(list, pid = 0, idKey = 'id', pidKey = 'pid', childKey = 'children') {\r\n        let res = [];\r\n        for (let i in list) {\r\n            let D = list[i];\r\n            if (D[pidKey] === pid) {\r\n                let r = this.listToTree(list, D[idKey], idKey, pidKey, childKey);\r\n                if (r.length) D[childKey] = r;\r\n                res.push(D);\r\n            }\r\n        }\r\n        return res;\r\n    },\r\n\r\n    /**\r\n     * 树状结构筛选\r\n     * 需要保证还有子节点的父节点不被过滤\r\n     * @param tree\r\n     * @param filter\r\n     * @param idKey\r\n     * @param childKey\r\n     * @param deep\r\n     * @param nowDeep\r\n     * @returns {Array}\r\n     */\r\n    filterTree(tree, filter, childKey = 'children', deep = null , nowDeep = 0) {\r\n        let res = [];\r\n        for (let leaf of tree) {\r\n            let show = (deep === null || deep === nowDeep + 1) && filter(leaf);\r\n            if (leaf.children && leaf.children.length) {\r\n                leaf.children = this.filterTree(leaf.children, filter, childKey, deep, nowDeep + 1);\r\n            }\r\n            if (show || (leaf.children && leaf.children.length)) {\r\n                res.push(leaf);\r\n            }\r\n        }\r\n        return res;\r\n    },\r\n\r\n\r\n    /**\r\n     * 将树状结构扁平化\r\n     * @param tree\r\n     * @param childKey\r\n     * @returns {Array}\r\n     */\r\n    platTrees(tree, childKey = 'children') {\r\n        let res = [];\r\n        for (let i in tree) {\r\n            let D = tree[i];\r\n            res.push(res);\r\n            if (D[childKey]) {\r\n                res.concat(this.platTrees(D[childKey, childKey]));\r\n            }\r\n        }\r\n        return res;\r\n    },\r\n\r\n    /**\r\n     * 查询路径\r\n     * @param tree\r\n     * @param find\r\n     * @param key\r\n     * @param childKey\r\n     * @param deep\r\n     * @param nowDeep\r\n     * @returns {Array}\r\n     */\r\n    getTreeRoute(tree, find, key = 'id', childKey = null, deep = null, nowDeep = 0) {\r\n        let ret = [];\r\n        childKey = childKey || 'children';\r\n        tree.forEach(x => {\r\n            let is = (deep === null || deep === nowDeep + 1) && find(x);\r\n            if (is) {\r\n                ret.push(x[key]);\r\n            } else if (x[childKey] && x[childKey].length) {\r\n                let r = this.getTreeRoute(x[childKey], find, key, childKey, deep, nowDeep + 1);\r\n                if (r.length) {\r\n                    ret = [x[key], ...r];\r\n                }\r\n            }\r\n        });\r\n        return ret;\r\n    },\r\n\r\n    /**\r\n     * 并集\r\n     * @param coll1\r\n     * @param coll2\r\n     * @returns {...*[]}\r\n     */\r\n    merge(coll1, coll2) {\r\n        return [...new Set([...coll1, ...coll2])];\r\n    },\r\n\r\n    /**\r\n     * 差集\r\n     * @param coll1\r\n     * @param coll2\r\n     * @param diff\r\n     * @returns {Array}\r\n     */\r\n    diff(coll1, coll2, diff = true) {\r\n        let ret = [];\r\n        coll1.forEach(x1 => {\r\n            let t = coll2.find(x2 => x2 === x1);\r\n            if (diff && !t) {\r\n                ret.push(x1);\r\n            }\r\n            if (!diff && t) {\r\n                ret.push(x1);\r\n            }\r\n        });\r\n        coll2.forEach(x1 => {\r\n            let t = coll1.find(x2 => x2 === x1);\r\n            if (diff && !t) {\r\n                ret.push(x1);\r\n            }\r\n            if (!diff && t) {\r\n                ret.push(x1);\r\n            }\r\n        });\r\n        return ret;\r\n    },\r\n\r\n    /**\r\n     * 交集\r\n     * @param coll1\r\n     * @param coll2\r\n     * @returns {*|Array}\r\n     */\r\n    intersect(coll1, coll2) {\r\n        return this.diff(coll1, coll2, false);\r\n    },\r\n\r\n    /**\r\n     * 交集和并集\r\n     * 如果存在交集 这取差集\r\n     * 如果不存在交集 则取并集\r\n     * @param coll1\r\n     * @param coll2\r\n     * @returns {*|Array|*}\r\n     */\r\n    mergeDiff(coll1, coll2) {\r\n        let m = this.merge(coll1, coll2);\r\n        if (m.length > coll1.length && m.length > coll2.length) {\r\n            return m;\r\n        }\r\n        let t = coll1.length > coll2.length ? coll2 : coll1;\r\n        return this.diff(m, t);\r\n    },\r\n    /**\r\n     * 将两个有所属关系的列表合并为树状结构\r\n     * @param parentList\r\n     * @param childList\r\n     * @param childKey\r\n     * @param idKey\r\n     * @param pid\r\n     * @returns {Array|*[]}\r\n     */\r\n    listToTreeByTwoList(parentList = [], childList = [], pid = 'id', childKey = 'children', idKey = 'id') {\r\n        if (!childList.length) return parentList;\r\n        return parentList.map(p => {\r\n            let c = {};\r\n            c[childKey] = childList.filter(ch => ch[pid] === p[idKey]);\r\n            return Object.assign(p, c);\r\n        });\r\n    }\r\n\r\n}\r\n"]}]}